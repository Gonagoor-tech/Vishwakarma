module Instruction_Mem(
    input         clk,
    input         reset,
    input  [63:0] read_address,  // renamed from addr
    output [31:0] instruction
);

    reg [31:0] memory [0:255];    // 1KB of instruction ROM
    reg [31:0] instruction_out;

    // Fetch on clock, clear output on reset
    always @(posedge clk or posedge reset) begin
        if (reset) begin
            instruction_out <= 32'b0;
        end else begin
            instruction_out <= memory[read_address[9:2]]; 
        end
    end

    assign instruction = instruction_out;

    // ----------------------------------------------------------------
    // ROM preload: R-type, I-type, W-type, load/store, branch, etc.
    // ----------------------------------------------------------------
    initial begin
        // Arithmetic (R-type)
        memory[0]  = 32'b0000000_00010_00001_000_00011_0110011; // add x3, x1, x2
        memory[1]  = 32'b0100000_00010_00001_000_00100_0110011; // sub x4, x1, x2
        memory[2]  = 32'b0000000_00010_00001_001_00101_0110011; // sll x5, x1, x2
        memory[3]  = 32'b0000000_00010_00001_010_00110_0110011; // slt x6, x1, x2
        memory[4]  = 32'b0000000_00010_00001_011_00111_0110011; // sltu x7, x1, x2
        memory[5]  = 32'b0000000_00010_00001_100_01000_0110011; // xor x8, x1, x2
        memory[6]  = 32'b0000000_00010_00001_101_01001_0110011; // srl x9, x1, x2
        memory[7]  = 32'b0100000_00010_00001_101_01010_0110011; // sra x10, x1, x2
        memory[8]  = 32'b0000000_00010_00001_110_01011_0110011; // or x11, x1, x2
        memory[9]  = 32'b0000000_00010_00001_111_01100_0110011; // and x12, x1, x2

        // Immediate Arithmetic (I-type)
        memory[10] = 32'b000000000100_00001_000_01101_0010011; // addi x13, x1, 4
        memory[11] = 32'b000000000100_00001_010_01110_0010011; // slti x14, x1, 4
        memory[12] = 32'b000000000100_00001_011_01111_0010011; // sltiu x15, x1, 4
        memory[13] = 32'b000000000100_00001_100_10000_0010011; // xori x16, x1, 4
        memory[14] = 32'b000000000100_00001_110_10001_0010011; // ori x17, x1, 4
        memory[15] = 32'b000000000100_00001_111_10010_0010011; // andi x18, x1, 4
        memory[16] = 32'b0000000_00100_00001_001_10011_0010011; // slli x19, x1, 4
        memory[17] = 32'b0000000_00100_00001_101_10100_0010011; // srli x20, x1, 4
        memory[18] = 32'b0100000_00100_00001_101_10101_0010011; // srai x21, x1, 4

        // Word Arithmetic (RV64)
        memory[19] = 32'b0000000_00010_00001_000_10110_0111011; // addw x22, x1, x2
        memory[20] = 32'b0100000_00010_00001_000_10111_0111011; // subw x23, x1, x2
        memory[21] = 32'b0000000_00010_00001_001_11000_0111011; // sllw x24, x1, x2
        memory[22] = 32'b0000000_00010_00001_101_11001_0111011; // srlw x25, x1, x2
        memory[23] = 32'b0100000_00010_00001_101_11010_0111011; // sraw x26, x1, x2
        memory[24] = 32'b000000000100_00001_000_11011_0011011; // addiw x27, x1, 4
        memory[25] = 32'b0000000_00100_00001_001_11100_0011011; // slliw x28, x1, 4
        memory[26] = 32'b0000000_00100_00001_101_11101_0011011; // srliw x29, x1, 4
        memory[27] = 32'b0100000_00100_00001_101_11110_0011011; // sraiw x30, x1, 4
        
        // Load
        memory[28] = 32'b000000000100_00001_000_11111_0000011; // lb x31, 4(x1)
        memory[29] = 32'b000000001000_00001_001_00001_0000011; // lh x1, 8(x1)
        memory[30] = 32'b000000001100_00001_010_00010_0000011; // lw x2, 12(x1)
        memory[31] = 32'b000000010000_00001_011_00011_0000011; // ld x3, 16(x1)
        memory[32] = 32'b000000010100_00001_100_00100_0000011; // lbu x4, 20(x1)
        memory[33] = 32'b000000011000_00001_101_00101_0000011; // lhu x5, 24(x1)
        memory[34] = 32'b000000011100_00001_110_00110_0000011; // lwu x6, 28(x1)

        // Store
        memory[35] = 32'b0000000_00111_00001_000_00000_0100011; // sb x7, 0(x1)
        memory[36] = 32'b0000000_01000_00001_001_00010_0100011; // sh x8, 2(x1)
        memory[37] = 32'b0000000_01001_00001_010_00100_0100011; // sw x9, 4(x1)
        memory[38] = 32'b0000000_01010_00001_011_00110_0100011; // sd x10, 6(x1)

        // Branch
        memory[39] = 32'b0000000_00010_00001_000_00000_1100011; // beq x1, x2, 0
        memory[40] = 32'b0000000_00010_00001_001_00000_1100011; // bne x1, x2, 0
        memory[41] = 32'b0000000_00010_00001_100_00000_1100011; // blt x1, x2, 0
        memory[42] = 32'b0000000_00010_00001_101_00000_1100011; // bge x1, x2, 0
        memory[43] = 32'b0000000_00010_00001_110_00000_1100011; // bltu x1, x2, 0
        memory[44] = 32'b0000000_00010_00001_111_00000_1100011; // bgeu x1, x2, 0

        // Jump
        memory[45] = 32'b00000000000000000000000000010111; // auipc x0, 0
        memory[46] = 32'b000000000100_00001_000_01010_1100111; // jalr x10, 4(x1)
        memory[47] = 32'b00000000000000000000000011101111; // jal x0, 0

        // Upper Immediate
        memory[48] = 32'b00000000000000000001_00010_0110111; // lui x2, 0x1
        memory[49] = 32'b00000000000000000010_00011_0010111; // auipc x3, 0x2

        // System
        memory[50] = 32'b00000000000000000000000001110011; // ecall
        memory[51] = 32'b00000000000100000000000001110011; // ebreak

        // RV64D (pseudo encodings - assume extended decoder)
        memory[52] = 32'h20000053; // fadd.d f0, f1, f2
        memory[53] = 32'h20001053; // fsub.d f0, f1, f2
        memory[54] = 32'h20002053; // fmul.d f0, f1, f2
        memory[55] = 32'h20003053; // fdiv.d f0, f1, f2
        memory[56] = 32'hc2200053; // fcvt.d.w f0, x0
        memory[57] = 32'hd2000053; // fcvt.w.d x0, f0
        memory[58] = 32'h20004053; // fsgnj.d f0, f1, f2
        memory[59] = 32'h20005053; // fsgnjn.d f0, f1, f2
        memory[60] = 32'h20006053; // fsgnjx.d f0, f1, f2
        memory[61] = 32'h2000a053; // feq.d x0, f1, f2
        memory[62] = 32'h2000b053; // flt.d x0, f1, f2
        memory[63] = 32'h2000c053; // fle.d x0, f1, f2
    end
endmodule
